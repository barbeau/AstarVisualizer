/**
 * Copyright 2005 Sean J. Barbeau
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.barbeau.networks.bayes;

import com.barbeau.networks.SearchSpace;
import com.barbeau.networks.astar.AstarSearch;
import com.barbeau.networks.astar.HeuristicsNode;
import com.barbeau.networks.astar.LinkXY;
import com.barbeau.networks.astar.NodeXY;
import com.barbeau.networks.visualization.MapDisplay;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.Iterator;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JSlider;

/**
 * This class defines the main user interface for the Polytree algorithm
 *
 * @author Sean Barbeau
 */
public class mainWindowPolytree extends javax.swing.JFrame {

    AstarSearch aStarProcess;
    //*** Variables that are passed to the main process ***
    public SearchSpace searchSpace = new SearchSpace();
    public BayesNode localStartNode;  //Start node for search algorithm
    public BayesNode localGoalNode;  //Goal node for search algorithm
    //*** Variables used to graphically display the nodes and search space ***
    //MapDisplay to show a map of the nodes in the GUI
    public MapDisplay map;
    //Variables that hold the size of the defined search space (800 x 800 for this project)
    public static int SEARCH_SPACE_WIDTH = 800;
    public static int SEARCH_SPACE_HEIGHT = 800;
    //Set scale of map in relation to the size of the search space (sizes the map and node positions accordingly)
    public static double SCALE = 0.66666; //Default scale of 2/3s
    //Define the sizes of the normal nodes vs. the currently node in the search
    public static int NORMAL_NODE_SIZE = 7;
    public static int EXPANDED_NODE_SIZE = 7;
    //Char for newline for text log
    private static String newline = "\n";
    //File chooser for letting the user pick the text file for node locations and connections
    JFileChooser fc;
    //Variable defines whether application runs quickly through (default) or step-by-step
    private boolean stepByStep = true;
    private HeuristicsNode previousStartNode = null;
    private HeuristicsNode previousGoalNode = null;

    /**
     * Creates new form mainWindow
     */
    public mainWindowPolytree() {
        initComponents();
        //Toolkit toolkit = Toolkit.getDefaultToolkit();

        System.out.println("Created mainWindow for user interface.");

        //Add beginning instructions to user to text box
        this.printToLog("Please put the input files in the same directory as this application, or specify another location using 'Browse' buttons.");
        this.printToLog("Click 'Load files' once the files are selected.");

        try {
            //Has the first heuristic "Fewest links" selected as default
            //this.jRadioButton1.doClick();
            //Have the user move a node when clicking on it by default            

            //Create map to display nodes to user             
            createMap();

        } catch (Exception e) {
            System.out.println("Error in mainWindow(): " + e);
            showError(e);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        jLabel2 = new javax.swing.JLabel();
        jButton3 = new javax.swing.JButton();
        txtNetworkName = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jComboNodes = new javax.swing.JComboBox();
        jComboEvidence = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jToggleButton1 = new javax.swing.JToggleButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jSlider1 = new javax.swing.JSlider();
        jLabel10 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        rbtnEnableDisableNode = new javax.swing.JRadioButton();
        rbtnMoveNode = new javax.swing.JRadioButton();
        jRadioButton5 = new javax.swing.JRadioButton();
        jRadioButton6 = new javax.swing.JRadioButton();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("PolyTree Algorithm");
        setBackground(new java.awt.Color(252, 252, 250));
        setResizable(false);
        addWindowFocusListener(new java.awt.event.WindowFocusListener() {
            public void windowGainedFocus(java.awt.event.WindowEvent evt) {
                handlewindowGainedFocus(evt);
            }
            public void windowLostFocus(java.awt.event.WindowEvent evt) {
            }
        });
        getContentPane().setLayout(null);

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel2.setText("Network File");
        getContentPane().add(jLabel2);
        jLabel2.setBounds(-10, 10, 100, 20);

        jButton3.setText("Load files");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton3);
        jButton3.setBounds(640, 10, 90, 23);

        txtNetworkName.setText("Sean's Network.xdsl");
        getContentPane().add(txtNetworkName);
        txtNetworkName.setBounds(100, 10, 120, 20);

        jScrollPane1.setBorder(javax.swing.BorderFactory.createTitledBorder("Polytree algorithm log"));

        jTextArea2.setEditable(false);
        jTextArea2.setFont(new java.awt.Font("Courier", 0, 12)); // NOI18N
        jTextArea2.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jTextArea2PropertyChange(evt);
            }
        });
        jScrollPane1.setViewportView(jTextArea2);

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(10, 30, 730, 140);

        jComboNodes.setEnabled(false);
        jComboNodes.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboNodesActionPerformed(evt);
            }
        });
        getContentPane().add(jComboNodes);
        jComboNodes.setBounds(610, 190, 80, 20);

        jComboEvidence.setEnabled(false);
        getContentPane().add(jComboEvidence);
        jComboEvidence.setBounds(610, 240, 80, 20);

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel3.setText("Select Node:");
        getContentPane().add(jLabel3);
        jLabel3.setBounds(610, 170, 80, 20);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Set Evidence:");
        getContentPane().add(jLabel4);
        jLabel4.setBounds(600, 220, 90, 20);

        jButton1.setText("Update Beliefs");
        jButton1.setEnabled(false);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton1);
        jButton1.setBounds(600, 640, 130, 23);

        jButton2.setText("Reset");
        jButton2.setEnabled(false);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton2);
        jButton2.setBounds(660, 700, 75, 23);

        jButton4.setText("Browse...");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton4);
        jButton4.setBounds(220, 10, 90, 20);

        jToggleButton1.setSelected(true);
        jToggleButton1.setText("Step-by-Step");
        jToggleButton1.setEnabled(false);
        jToggleButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButton1ActionPerformed(evt);
            }
        });
        getContentPane().add(jToggleButton1);
        jToggleButton1.setBounds(600, 540, 120, 23);

        jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel6.setText("Toggle 'Step' feature");
        getContentPane().add(jLabel6);
        jLabel6.setBounds(600, 520, 130, 14);

        jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel7.setText("Step time (Seconds)");
        getContentPane().add(jLabel7);
        jLabel7.setBounds(590, 570, 140, 14);

        jLabel8.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel8.setText("1");
        getContentPane().add(jLabel8);
        jLabel8.setBounds(600, 620, 20, 14);

        jLabel9.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel9.setText("10");
        getContentPane().add(jLabel9);
        jLabel9.setBounds(700, 620, 34, 14);

        jSlider1.setMajorTickSpacing(1000);
        jSlider1.setMaximum(10000);
        jSlider1.setMinimum(100);
        jSlider1.setPaintTicks(true);
        jSlider1.setValue(1000);
        jSlider1.setEnabled(false);
        jSlider1.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jSlider1PropertyChange(evt);
            }
        });
        jSlider1.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSlider1StateChanged(evt);
            }
        });
        jSlider1.addInputMethodListener(new java.awt.event.InputMethodListener() {
            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
                jSlider1CaretPositionChanged(evt);
            }
            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
            }
        });
        getContentPane().add(jSlider1);
        jSlider1.setBounds(590, 590, 140, 31);

        jLabel10.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel10.setText("On mouse click:");
        getContentPane().add(jLabel10);
        jLabel10.setBounds(590, 350, 120, 20);

        jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel3.setLayout(null);

        buttonGroup2.add(rbtnEnableDisableNode);
        rbtnEnableDisableNode.setText("Enable/Disable Node");
        rbtnEnableDisableNode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtnEnableDisableNodeActionPerformed(evt);
            }
        });
        jPanel3.add(rbtnEnableDisableNode);
        rbtnEnableDisableNode.setBounds(10, 0, 140, 23);

        buttonGroup2.add(rbtnMoveNode);
        rbtnMoveNode.setText("Move Node");
        rbtnMoveNode.setMargin(new java.awt.Insets(1, 2, 2, 2));
        rbtnMoveNode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtnMoveNodeActionPerformed(evt);
            }
        });
        jPanel3.add(rbtnMoveNode);
        rbtnMoveNode.setBounds(10, 20, 130, 21);

        getContentPane().add(jPanel3);
        jPanel3.setBounds(580, 370, 160, 50);

        buttonGroup1.add(jRadioButton5);
        jRadioButton5.setText("Fewest Links");
        getContentPane().add(jRadioButton5);
        jRadioButton5.setBounds(10, 80, 87, 23);

        buttonGroup1.add(jRadioButton6);
        jRadioButton6.setText("Shortest Distance");
        jRadioButton6.setMargin(new java.awt.Insets(1, 2, 2, 2));
        getContentPane().add(jRadioButton6);
        jRadioButton6.setBounds(10, 80, 111, 21);

        jLabel11.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel11.setText("Node Key:");
        getContentPane().add(jLabel11);
        jLabel11.setBounds(580, 430, 60, 14);

        jLabel12.setForeground(new java.awt.Color(0, 0, 255));
        jLabel12.setText("Start and Goal");
        getContentPane().add(jLabel12);
        jLabel12.setBounds(650, 430, 90, 14);

        jLabel13.setForeground(new java.awt.Color(255, 0, 51));
        jLabel13.setText("Disabled");
        getContentPane().add(jLabel13);
        jLabel13.setBounds(650, 450, 70, 14);

        jLabel14.setForeground(new java.awt.Color(51, 255, 0));
        jLabel14.setText("Current");
        getContentPane().add(jLabel14);
        jLabel14.setBounds(650, 470, 70, 14);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-753)/2, (screenSize.height-765)/2, 753, 765);
    }// </editor-fold>//GEN-END:initComponents

    private void rbtnMoveNodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtnMoveNodeActionPerformed
        // Set mouse click to move nodes and not to enable/disable them
        try {
            this.map.setAllowDisableNode(false);
            this.map.setAllowMoveNode(true);
            System.out.println("Will allow moving nodes now on mouse click");
        } catch (Exception e) {
            System.out.println("Error allowing moving nodes: " + e);
            showError(e);
        }

    }//GEN-LAST:event_rbtnMoveNodeActionPerformed

    private void rbtnEnableDisableNodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtnEnableDisableNodeActionPerformed
        // Set mouse click to enable/disable nodes and not to move them
        try {
            this.map.setAllowMoveNode(false);
            this.map.setAllowDisableNode(true);
            System.out.println("Will allow enabling/disabling nodes now on mouse click");
        } catch (Exception e) {
            System.out.println("Error allowing enable/disable nodes: " + e);
            showError(e);
        }

    }//GEN-LAST:event_rbtnEnableDisableNodeActionPerformed

    private void handlewindowGainedFocus(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_handlewindowGainedFocus
    }//GEN-LAST:event_handlewindowGainedFocus

    private void jSlider1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSlider1StateChanged
        JSlider source = (JSlider) evt.getSource();

        //this.printToLog("New slider value is: " + source.getValue());

        try {
            aStarProcess.setTimeDelay(source.getValue());
        } catch (Exception e) {
            System.out.println("Error changing slider value: " + e);
        }
    }//GEN-LAST:event_jSlider1StateChanged

    private void jSlider1CaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jSlider1CaretPositionChanged
    }//GEN-LAST:event_jSlider1CaretPositionChanged

    private void jSlider1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jSlider1PropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jSlider1PropertyChange

    private void jToggleButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButton1ActionPerformed
        if (this.jToggleButton1.isSelected() == true) {
            this.printToLog("The program will now step through the algorithm one event at a time");
            try {
                this.stepByStep = true;
                this.aStarProcess.setStepByStep(true);
            } catch (Exception e) {
                System.out.println("Error setting step-by-step: " + e);
                //show_error(e);
            }
        } else {
            this.printToLog("The program will now quickly run the algorithm without stopping");
            try {
                this.stepByStep = false;
                this.aStarProcess.setStepByStep(false);
            } catch (Exception e) {
                System.out.println("Error setting step-by-step: " + e);
                //show_error(e);
            }
        }
    }//GEN-LAST:event_jToggleButton1ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        //Opens file handler to file text field with path to file for "Locations" file

        //Create new file chooser
        fc = new JFileChooser();

        try {
            int returnVal = fc.showOpenDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = fc.getSelectedFile();
                //this.printToLog("Selected: " + file.getAbsolutePath());    
                this.txtNetworkName.setText(file.getAbsolutePath());
            }
        } catch (Exception e) {
            System.out.println("Error in getting location filename: " + e);
        }

    }//GEN-LAST:event_jButton4ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        //Reset the algorithm and form
        this.reset();
        //Disable reset button
        this.jButton2.setEnabled(false);
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jTextArea2PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jTextArea2PropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jTextArea2PropertyChange

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        //**********************************************************
        //* Load and create nodes and fills their properties *
        //********************************************************** 

        try {
            //Get filenames from text boxes         
            String networkFileName = txtNetworkName.getText();
            //String conn_filename = jTextField1.getText();

            //Clear local search space
            this.clearSearchSpace();

            //Clear map
            //this.map.clear();

            this.printToLog("Loading files.....");

            //Load nodes with their locations from file
            this.loadNetwork(networkFileName);

            //Load node connections from file
            //this.loadNodeConn(conn_filename);

            //Clear combo boxes in case some items exist from previous executions of algorithm
            this.jComboNodes.removeAllItems();
            this.jComboEvidence.removeAllItems();

            //Load start and goal combo boxes with node names
            this.fillComboBoxes(this.jComboNodes, this.jComboEvidence);

            //Try and load previous start and goal nodes from previous algorithm run to combo boxes if they exist
//            try {
//                this.jComboBox1.setSelectedItem(this.previous_start_node.label);
//                this.jComboBox2.setSelectedItem(this.previous_goal_node.label);
//                //System.out.println("Successfully loaded previously selected start and goal nodes from last execution of algorithm.");
//            }
//            catch(Exception e) {
//                System.out.println("Error loading previous start and goal nodes: " + e);
//            }
            //Creates the connections between the nodes on the screen
            //this.paintNodeConnections();

            //Create the map of the nodes on the screen
            // this.paintInitMap();

            //Enabled radio buttons for selection of the heuristic
//            this.jRadioButton1.setEnabled(true);
//            this.jRadioButton2.setEnabled(true);

            //Enable clicking on map
            this.map.setAllowClicks(true);

            //Enable Step-by-step button
            this.jToggleButton1.setEnabled(true);

            //Enable step slider
            this.jSlider1.setEnabled(true);


            this.printToLog("*************************************************************************************************************************");
            this.printToLog("Please select a the node you would like to inject evidence for, then click 'Start'");
            //this.printToLog("Click on nodes to toggle them as 'Enabled' (default) or 'Disabled' so the algorithm does not use them in the search.");
            //this.printToLog("Use the toggle 'Step-by-Step' button to specify whether the algorithm should proceed step-by-step (default) or automatically run.");
            this.printToLog("*************************************************************************************************************************");

            //Set button and text field properties
            //jTextField1.setEnabled(true);
            txtNetworkName.setEnabled(true);
            jButton1.setEnabled(true);
            jButton3.setEnabled(true);
            jComboNodes.setEnabled(true);
            jComboEvidence.setEnabled(true);
            this.map.setAllowDisableNode(false);
            this.map.setAllowMoveNode(true);//Set default button to move nodes

            this.rbtnMoveNode.doClick();  //Set default button to move nodes

            JOptionPane.showMessageDialog(null, "The network has been loaded successfully.  Please select the appropriate options and update beliefs.", "Files Loaded", JOptionPane.INFORMATION_MESSAGE);

        } catch (Exception e) {
            //Print out error to output window
            System.out.println(e);
            //this.map.clear();
            this.jButton1.setEnabled(false);  //Disable start button
            JOptionPane.showMessageDialog(null, "There was an error loading the files.  Please make sure the files are in the same directory as this application, or that they exist in the specified directories and try again.", "Error", JOptionPane.ERROR_MESSAGE);
        }


    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        //**********************
        //* Start PolyTree algorithm *
        //**********************

        System.out.println("This command button starts the algorithm");

        //Get start and goal nodes for algorithm
        this.initializeAlgorithm();

        //Check to see if either start or goal node are disabled
        if (this.localStartNode.enabled == false || this.localGoalNode.enabled == false) {
            //Stop starting of algorithm, since start or goal node cannot be disabled
            //this.printToLog("****************************************************************************************************");
            this.printToLog("ERROR: Cannot start algorithm if Start or Goal nodes are disabled, since no solution will be found.");
            this.printToLog("Please enable Start node '" + this.localStartNode.label + "' and Goal node '" + this.localGoalNode.label + "' and restart the algorithm.");

            JOptionPane.showMessageDialog(null, "Start node '" + this.localStartNode.label + "' and Goal node '" + this.localGoalNode.label + "' must be enabled for a solution to be found.  Please enable these nodes and restart the algorithm.", "Error Starting Algorithm", JOptionPane.ERROR_MESSAGE);
        } else {
            //Proceed with algorithm
            try {
                //Disable clicking on map
                this.map.setAllowClicks(false);

                //Disable 'Start' button so two threads can't be running at once
                this.jButton1.setEnabled(false);

                //Disable browse buttons
                this.jButton4.setEnabled(false);
                //this.jButton5.setEnabled(false);

                //Change colors for the start and goal nodes
                this.paintStartAndGoal();

                //Instatiate the AstarSearch process
                //aStarProcess = new AstarSearch(this.local_search_space, this.localStartNode, this.localGoalNode, this.selected_heuristic, this.jTextArea2, this.map);

                //Set step-by-step value
                //aStarProcess.setStepByStep(this.step_by_step);

//                try {
//                    //Set step_time_delay
//                    int step_time_delay = this.jSlider1.getValue();
//                    aStarProcess.setTimeDelay(step_time_delay);
//                }
//                catch (Exception e) {
//                    System.out.println("Error setting up algorithm: " + e);
//                    showError(e);
//                }
//
//                //Start process
//                aStarProcess.start();

                //Enable pause button
                //this.jButton6.setEnabled(true);
                //Enable reset button
                this.jButton2.setEnabled(true);

                //Disable combo boxes
                this.jComboNodes.setEnabled(false);
                this.jComboEvidence.setEnabled(false);

                //Disable heuristics radio buttons
//                this.jRadioButton1.setEnabled(false);
//                this.jRadioButton2.setEnabled(false);

                //Disable click radio buttons
                this.rbtnEnableDisableNode.setEnabled(false);
                this.rbtnMoveNode.setEnabled(false);
            } catch (Exception E) {
                System.out.println("Error starting A* algorithm " + E);
                showError(E);
            }
            //jTextField1.setEnabled(false);
            txtNetworkName.setEnabled(false);
            //jButton1.setEnabled(false);
            jButton3.setEnabled(false);
        } //end of ELSE to detect if start or goal nodes are disabled
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * When the user selects a node from the list, show the list of evidence
     * options from the 2nd combo box
     *
     * @param evt
     */
    private void jComboNodesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboNodesActionPerformed
        System.out.println("Filling combo box with evidence of " + (String) jComboNodes.getSelectedItem() + ":");

        BayesNode tempNode;
        jComboEvidence.removeAllItems();  //Clear the evidence list
        //Add list of evidence options (i.e., row names) for the selected node
        tempNode = (BayesNode) searchSpace.findNode((String) jComboNodes.getSelectedItem());
        Iterator j = tempNode.rowNames.iterator();
        while (j.hasNext()) {
            String temp = (String) j.next();
            jComboEvidence.addItem(temp);
            System.out.println(temp);
        }
    }//GEN-LAST:event_jComboNodesActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new mainWindowPolytree().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JComboBox jComboEvidence;
    private javax.swing.JComboBox jComboNodes;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JRadioButton jRadioButton5;
    private javax.swing.JRadioButton jRadioButton6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSlider jSlider1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JToggleButton jToggleButton1;
    private javax.swing.JRadioButton rbtnEnableDisableNode;
    private javax.swing.JRadioButton rbtnMoveNode;
    private javax.swing.JTextField txtNetworkName;
    // End of variables declaration//GEN-END:variables

    /**
     * Loads the initial Genie file that creates the nodes and sets their
     * location
     *
     * @param networkFileName name of the Genie file that contains the network
     */
    public void loadNetwork(String networkFileName) {

        System.out.println("Creating nodes from Genie file...");

        GenieParser genieParser = new GenieParser();

        genieParser.parseXDSLFile(networkFileName, this.searchSpace);

    }

    /**
     * Loads the connections file that sets up how each node is connected to its
     * neighbors
     *
     * @param connFilename name of file that contains connection info for nodes
     */
    public void loadNodeConn(String connFilename) {

        System.out.println("Creating node connections...");

        //Create buffered file reader
        BufferedReader input = null;

        try {
            //Set file input variables
            input = new BufferedReader(new FileReader(connFilename));

            //Initialize string to read in lines from file
            String line = null;

            //Loop to read file line-by-line
            while ((line = input.readLine()) != null) {
                //Process each line of text file

                //System.out.println("File line: " + line); //Test read file by printing the entire line

                //PARSING CODE for Location of nodes text file "locsamp.txt"
                String nodeInfo[] = line.split(" ");
                if ((nodeInfo != null) && (nodeInfo.length > 1)) {

                    //System.out.println("Searching for Node '" + node_info[0] + "' to form connections from....");

                    //Get node_A to add connections to 
                    NodeXY nodeA = (NodeXY) this.searchSpace.findNode(nodeInfo[0]);

                    //System.out.println("Got node '" + node_info[0] + "'.");

                    //Get # of nodes that node_A is connected to
                    int numConn = Integer.parseInt(nodeInfo[1]);

                    //Print node info                    
                    //System.out.println("Node '" + node_info[0] + "' has " + numConn + " initial connections:");
                    //Get each connection
                    for (int i = 2; i < (numConn + 2); i++) {

                        //System.out.println("Searching for Node '" + node_info[i] + "' to form connection to....");

                        //Get each node to connect to
                        NodeXY nodeB = (NodeXY) this.searchSpace.findNode(nodeInfo[i]);

                        //System.out.println("Got node '" + node_info[i] + "'.");

                        if (nodeB != null && nodeA != null) {
                            //Add one-way connection from node_A to node_B
                            nodeA.addConnToChild(nodeB);

                            //Add link to search space
                            LinkXY link = new LinkXY(nodeA, nodeB);
                            this.searchSpace.add(link);

                        } else {
                            System.out.println("Error:  Tried to form connection to or from a node that does not exist in search space.");
                        }
                        //Prints the label for each node that will be connected to
                        //System.out.println(node_info[i]);
                    }

                }

            }
            this.printToLog("Files were successfully loaded.");

            //JOptionPane.showMessageDialog(this, "Files successfully loaded.  Please choose the start and goal nodes and click 'Start'","Files loaded", JOptionPane.INFORMATION_MESSAGE);

        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, e, "Error", JOptionPane.ERROR_MESSAGE);
            System.out.println(e);
        }

        System.out.println("Finished creating node connections.");

        try {
            //Close input file
            input.close();

        } catch (java.io.IOException e) {
            System.out.println(e);
            showError(e);
        }
    }

    /**
     * Fills the nodes and evidence combo boxes
     *
     * @param comboNodes combo box that will contain the nodes info
     * @param comboEvidence combo box that will contain the evidence info
     */
    public void fillComboBoxes(javax.swing.JComboBox comboNodes, javax.swing.JComboBox comboEvidence) {

        //Temp node to loop through search space
        BayesNode tempNode;

        //Get iterator to loop through search_space
        Iterator i = this.searchSpace.getNodeIterator();

        while (i.hasNext()) {
            //Get next node
            tempNode = (BayesNode) i.next();
            //Add string to combo box for nodes
            comboNodes.addItem(tempNode.label);

        }
    }

    /**
     * Initializes the start and goal nodes of the algorithm *
     */
    public void initializeAlgorithm() {

        NodeXY tempNode;  //Temp node to loop through search space

        Iterator i = this.searchSpace.getNodeIterator();  //Get iterator to loop through search_space

        while (i.hasNext()) {
            //Get next node
            tempNode = (NodeXY) i.next();
            //Clear node attributes used for search (allows multiple searches)
            tempNode.costFromStart = 0;
            //temp_node.enabled = true;  //Commented out to allow nodes to be disabled
            tempNode.estCostToGoal = 0;
            tempNode.pathParent = null;
        }

        //Get names of selected start and goal nodes
        String startNodeLabel = (String) jComboNodes.getSelectedItem();
        String goalNodelabel = (String) jComboEvidence.getSelectedItem();

        //Find start and goal nodes                
        localStartNode = (BayesNode) this.searchSpace.findNode(startNodeLabel);
        localGoalNode = (BayesNode) this.searchSpace.findNode(goalNodelabel);

    }

    /**
     * Prints output shown to the user in the textbox on the screen
     *
     * @param text text to be shown to the user
     */
    public void printToLog(String text) {

        try {
            this.jTextArea2.append(text + newline); //Adds newline character so each entry appears on a new line

            //Moves cursor to the end of the text area to keep new text in view
            this.jTextArea2.setCaretPosition(jTextArea2.getDocument().getLength());

            //Print out to output screen also
            System.out.println(text);
        } catch (Exception e) {
            System.out.println("Error in mainWindow.print_to_log:" + e);
            showError(e);
        }

    }

    /**
     * Creates the map display
     */
    public void createMap() {

        try {
            //Create map
            map = new MapDisplay();

            //Set map variables for search space
            this.map.setSearchSpace(this.searchSpace, this.SEARCH_SPACE_WIDTH, this.SEARCH_SPACE_HEIGHT, this.SCALE, this.NORMAL_NODE_SIZE, this.EXPANDED_NODE_SIZE);

            //Set map variable to print messages to the user
            map.setTextLog(this.jTextArea2);

            //Setup map
            //map.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());  //Changed to below "null" due to error running .jar
            map.setLayout(null);
            map.setBackground(new java.awt.Color(251, 250, 247));
            map.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0)));
            this.getContentPane().add(map);
            map.setBounds(20, 170, (int) ((SEARCH_SPACE_WIDTH + 30) * SCALE), (int) ((SEARCH_SPACE_HEIGHT + 30) * SCALE)); //"+ 20" value lets you read the labels on the nodes on the far bottom and right extremes

            //Show the blank map
            map.show();
        } catch (Exception e) {
            System.out.println("Error creating map: " + e);
            showError(e);
        }
    }

    /**
     * Draws the initial view of nodes on the map
     */
    public void paintInitMap() {

        //Draw initial node setup on the map
        Iterator i = this.searchSpace.getNodeIterator();

        //Color color = Color.DARK_GRAY;  //Color for nodes

        HeuristicsNode tempNode; //Variable to loop through search space

        while (i.hasNext()) {
            tempNode = (HeuristicsNode) i.next();  //Get next node

            /*
             * if (temp_node == this.localStartNode) { //Change color for
             * start_node color = Color.BLUE; } else { if (temp_node ==
             * this.localGoalNode) { //Change color for goal_node color =
             * Color.ORANGE; } }
             */

            tempNode.drawNode(map, tempNode.color, NORMAL_NODE_SIZE);  //Draw node on map            
        }
    }

    /**
     * Paints the colors of the start and goal nodes on the map
     */
    public void paintStartAndGoal() {

        Color color = Color.BLACK;  //Color for node (default = BLACK)

        //Change color for start_node
        color = Color.BLUE;
//       this.localStartNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map
//       this.localStartNode.previousColor = Color.BLUE;
//
//       //Change color for goal_node
//       color = Color.BLUE;
//       this.localGoalNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map
//       this.localGoalNode.previousColor = Color.BLUE;
    }

    /**
     * Paints the colors of the start and goal nodes on the map
     */
    public void resetStartGoalCurrentColors() {

        Color color = Color.DARK_GRAY;  //Color for node

        //Change color for start_node
//       this.localStartNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map
//       this.localStartNode.previousColor = color;
//
//       //Change color for goal_node
//       this.localGoalNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map
//       this.localGoalNode.previousColor = color;

        //Change color for current_node
        try {
            HeuristicsNode temp_node = this.aStarProcess.getCurrentNode();
            temp_node.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map                        
        } catch (Exception e) {
            System.out.println("Error resetting current node color: " + e);
        }

    }

    /**
     * Paints the connections between the nodes
     */
    public void paintNodeConnections() {

        Color color = Color.LIGHT_GRAY;  //Color for link

        //*** Draw all links on map ***
        Iterator i2 = this.searchSpace.getLinkIterator();

        LinkXY tempLink; //Variable to loop through search space

        while (i2.hasNext()) {
            tempLink = (LinkXY) i2.next();  //Get next link

            tempLink.drawLink(this.map, color);  //Draw link on map                            
        }
    }

    /**
     * Resets the algorithm and GUI so that the user can restart the algorithm
     */
    public void reset() {

        //Save last start and goal so they can be reloaded
//    this.previous_start_node = this.localStartNode;
//    this.previous_goal_node = this.localGoalNode;

        //Clear map
        //map.clear();

        //Clear combo boxes
        //this.jComboBox1.removeAllItems();
        //this.jComboBox2.removeAllItems();

        try {
            this.aStarProcess.suspend();
        } catch (Exception e) {
            System.out.println(e);
        }

        //Reset link traveled status and colors
        resetLinkStatus();

        //Reset start and goal and current node colors
        resetStartGoalCurrentColors();

        //Repaint links on map
        paintNodeConnections();

        //Repaint nodes on map
        paintInitMap();

        //Enable Start button and combo boxes
        this.jToggleButton1.setEnabled(true);
        this.jComboNodes.setEnabled(true);
        this.jComboEvidence.setEnabled(true);
//    this.jRadioButton1.setEnabled(true);
//    this.jRadioButton2.setEnabled(true);
        this.rbtnEnableDisableNode.setEnabled(true);
        this.rbtnMoveNode.setEnabled(true);
        this.jButton1.setEnabled(true);
        this.jSlider1.setEnabled(true);

        //Enable load buttons and fields
        this.jButton3.setEnabled(true);
        this.jButton4.setEnabled(true);
        //this.jButton5.setEnabled(true);
        //this.jTextField1.setEnabled(true);
        //this.jTextField2.setEnabled(true);

        //Enable clicking on map
        this.map.setAllowClicks(true);

        //Print reset message to the user
        this.printToLog("The algorithm has been reset.");
    }

    /**
     * Resets all links to their default states
     */
    public void resetLinkStatus() {

        //*** Draw all links on map ***
        Iterator i2 = this.searchSpace.getLinkIterator();

        LinkXY tempLink; //Variable to loop through search space

        while (i2.hasNext()) {
            tempLink = (LinkXY) i2.next();  //Get next link

            tempLink.resetToDefault();  //Reset link                     
        }
    }

    /**
     * Clears the search space of all nodes
     */
    public void clearSearchSpace() {

        //Point to new search space
        this.searchSpace = new SearchSpace();

        //Set map variables for new search space
        this.map.setSearchSpace(this.searchSpace, this.SEARCH_SPACE_WIDTH, this.SEARCH_SPACE_HEIGHT, this.SCALE, this.NORMAL_NODE_SIZE, this.EXPANDED_NODE_SIZE);
    }

    /**
     * Shows an error to the user
     *
     * @param e Exception to show to the user
     */
    public void showError(Exception e) {
        JOptionPane.showMessageDialog(null, "Error: " + e, "Error", JOptionPane.ERROR_MESSAGE);
    }
}