/**
 * Copyright 2005 Sean J. Barbeau
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.barbeau.networks.astar;

import com.barbeau.networks.visualization.MapDisplay;
import com.barbeau.networks.SearchSpace;
import java.util.*;
import java.awt.*;
import java.io.*;
import javax.swing.*;
import java.util.Collections.*;

/**
 * This class defines the main user interface for the algorithm to be executed
 * and displayed
 *
 * @author Sean Barbeau
 */
public class mainWindowAstar extends javax.swing.JFrame {
    //******************************************
    //* Main Window to show A*Search algorithm *
    //******************************************

    AstarSearch aStarProcess;
    //*** Variables that are passed to the main process ***
    public SearchSpace localSearchSpace = new SearchSpace();
    public HeuristicsNode localStartNode;  //Start node for search algorithm
    public HeuristicsNode localGoalNode;  //Goal node for search algorithm
    public int selectedHeuristic = 1;//Variable that holds which heuristic is selected by the user (1 = Fewest # of links, 2 = Shortest distance).  1 is the default
    //*** Variables used to graphically display the nodes and search space ***
    //MapDisplay to show a map of the nodes in the GUI
    public MapDisplay map;
    //Variables that hold the size of the defined search space (800 x 800 for this project)
    public static int SEARCH_SPACE_WIDTH = 800;
    public static int SEARCH_SPACE_HEIGHT = 800;
    //Set scale of map in relation to the size of the search space (sizes the map and node positions accordingly)
    public static double SCALE = 0.66666; //Default scale of 2/3s
    //Define the sizes of the normal nodes vs. the currently node in the search
    public static int NORMAL_NODE_SIZE = 7;
    public static int EXPANDED_NODE_SIZE = 7;
    //Char for newline for text log
    private static String newline = "\n";
    //File chooser for letting the user pick the text file for node locations and connections
    JFileChooser fc;
    //Variable defines whether application runs quickly through (default) or step-by-step
    private boolean stepByStep = true;
    private HeuristicsNode previousStartNode = null;
    private HeuristicsNode previousGoalNode = null;

    /**
     * Creates new form mainWindow
     */
    public mainWindowAstar() {
        initComponents();
        //Toolkit toolkit = Toolkit.getDefaultToolkit();

        System.out.println("Created mainWindow for user interface.");

        //Add beginning instructions to user to text box
        this.printToLog("Please put the input files in the same directory as this application, or specify another location using 'Browse' buttons.");
        this.printToLog("Click 'Load files' once the files are selected.");

        try {
            //Has the first heuristic "Fewest links" selected as default
            this.jRadioButton1.doClick();

            //Create map to display nodes to user             
            createMap();

            //Set default click on map to enable/disable nodes
            this.jRadioButton3.doClick();
        } catch (Exception e) {
            System.out.println("Error in mainWindow(): " + e);
            showError(e);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jButton3 = new javax.swing.JButton();
        jTextField2 = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jComboBox1 = new javax.swing.JComboBox();
        jComboBox2 = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jButton2 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jToggleButton1 = new javax.swing.JToggleButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jSlider1 = new javax.swing.JSlider();
        jLabel10 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jRadioButton3 = new javax.swing.JRadioButton();
        jRadioButton4 = new javax.swing.JRadioButton();
        jRadioButton5 = new javax.swing.JRadioButton();
        jRadioButton6 = new javax.swing.JRadioButton();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("A* Algorithm");
        setBackground(new java.awt.Color(252, 252, 250));
        setResizable(false);
        addWindowFocusListener(new java.awt.event.WindowFocusListener() {
            public void windowGainedFocus(java.awt.event.WindowEvent evt) {
                handlewindowGainedFocus(evt);
            }
            public void windowLostFocus(java.awt.event.WindowEvent evt) {
            }
        });
        getContentPane().setLayout(null);

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel1.setText("'Connections' File:");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(290, 10, 110, 20);

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel2.setText("'Locations' File:");
        getContentPane().add(jLabel2);
        jLabel2.setBounds(-10, 10, 100, 20);

        jTextField1.setText("connsamp.txt");
        getContentPane().add(jTextField1);
        jTextField1.setBounds(400, 10, 100, 20);

        jButton3.setText("Load files");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton3);
        jButton3.setBounds(640, 10, 90, 23);

        jTextField2.setText("locsamp.txt");
        getContentPane().add(jTextField2);
        jTextField2.setBounds(100, 10, 100, 20);

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel2.setLayout(null);

        buttonGroup1.add(jRadioButton1);
        jRadioButton1.setText("Fewest Links");
        jRadioButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton1ActionPerformed(evt);
            }
        });
        jPanel2.add(jRadioButton1);
        jRadioButton1.setBounds(10, 0, 100, 23);

        buttonGroup1.add(jRadioButton2);
        jRadioButton2.setText("Shortest Distance");
        jRadioButton2.setMargin(new java.awt.Insets(1, 2, 2, 2));
        jRadioButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton2ActionPerformed(evt);
            }
        });
        jPanel2.add(jRadioButton2);
        jRadioButton2.setBounds(10, 20, 130, 21);

        getContentPane().add(jPanel2);
        jPanel2.setBounds(580, 290, 160, 50);

        jScrollPane1.setBorder(javax.swing.BorderFactory.createTitledBorder("A* algorithm log"));

        jTextArea2.setEditable(false);
        jTextArea2.setFont(new java.awt.Font("Courier", 0, 12));
        jTextArea2.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jTextArea2PropertyChange(evt);
            }
        });
        jScrollPane1.setViewportView(jTextArea2);

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(10, 30, 730, 140);

        jComboBox1.setEnabled(false);
        getContentPane().add(jComboBox1);
        jComboBox1.setBounds(610, 190, 80, 20);

        jComboBox2.setEnabled(false);
        getContentPane().add(jComboBox2);
        jComboBox2.setBounds(610, 240, 80, 20);

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel3.setText("Start Node:");
        getContentPane().add(jLabel3);
        jLabel3.setBounds(610, 170, 80, 20);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Goal Node:");
        getContentPane().add(jLabel4);
        jLabel4.setBounds(600, 220, 90, 20);

        jButton1.setText("Start");
        jButton1.setEnabled(false);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton1);
        jButton1.setBounds(620, 640, 80, 23);

        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel5.setText("Heuristic:");
        getContentPane().add(jLabel5);
        jLabel5.setBounds(590, 270, 90, 20);

        jButton2.setText("Reset");
        jButton2.setEnabled(false);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton2);
        jButton2.setBounds(660, 700, 75, 23);

        jButton4.setText("Browse...");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton4);
        jButton4.setBounds(200, 10, 90, 20);

        jButton5.setText("Browse...");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton5);
        jButton5.setBounds(500, 10, 90, 20);

        jToggleButton1.setSelected(true);
        jToggleButton1.setText("Step-by-Step");
        jToggleButton1.setEnabled(false);
        jToggleButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButton1ActionPerformed(evt);
            }
        });
        getContentPane().add(jToggleButton1);
        jToggleButton1.setBounds(600, 540, 120, 23);

        jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel6.setText("Toggle 'Step' feature");
        getContentPane().add(jLabel6);
        jLabel6.setBounds(600, 520, 130, 14);

        jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel7.setText("Step time (Seconds)");
        getContentPane().add(jLabel7);
        jLabel7.setBounds(590, 570, 140, 14);

        jLabel8.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel8.setText("1");
        getContentPane().add(jLabel8);
        jLabel8.setBounds(600, 620, 20, 14);

        jLabel9.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel9.setText("10");
        getContentPane().add(jLabel9);
        jLabel9.setBounds(700, 620, 34, 14);

        jSlider1.setMajorTickSpacing(1000);
        jSlider1.setMaximum(10000);
        jSlider1.setMinimum(100);
        jSlider1.setPaintTicks(true);
        jSlider1.setValue(1000);
        jSlider1.setEnabled(false);
        jSlider1.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jSlider1PropertyChange(evt);
            }
        });
        jSlider1.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSlider1StateChanged(evt);
            }
        });
        jSlider1.addInputMethodListener(new java.awt.event.InputMethodListener() {
            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
                jSlider1CaretPositionChanged(evt);
            }
            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
            }
        });
        getContentPane().add(jSlider1);
        jSlider1.setBounds(590, 590, 140, 31);

        jLabel10.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel10.setText("On mouse click:");
        getContentPane().add(jLabel10);
        jLabel10.setBounds(590, 350, 120, 20);

        jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel3.setLayout(null);

        buttonGroup2.add(jRadioButton3);
        jRadioButton3.setText("Enable/Disable Node");
        jRadioButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton3ActionPerformed(evt);
            }
        });
        jPanel3.add(jRadioButton3);
        jRadioButton3.setBounds(10, 0, 140, 23);

        buttonGroup2.add(jRadioButton4);
        jRadioButton4.setText("Move Node");
        jRadioButton4.setMargin(new java.awt.Insets(1, 2, 2, 2));
        jRadioButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton4ActionPerformed(evt);
            }
        });
        jPanel3.add(jRadioButton4);
        jRadioButton4.setBounds(10, 20, 130, 21);

        getContentPane().add(jPanel3);
        jPanel3.setBounds(580, 370, 160, 50);

        buttonGroup1.add(jRadioButton5);
        jRadioButton5.setText("Fewest Links");
        getContentPane().add(jRadioButton5);
        jRadioButton5.setBounds(10, 80, 87, 23);

        buttonGroup1.add(jRadioButton6);
        jRadioButton6.setText("Shortest Distance");
        jRadioButton6.setMargin(new java.awt.Insets(1, 2, 2, 2));
        getContentPane().add(jRadioButton6);
        jRadioButton6.setBounds(10, 80, 111, 21);

        jLabel11.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel11.setText("Node Key:");
        getContentPane().add(jLabel11);
        jLabel11.setBounds(580, 430, 60, 14);

        jLabel12.setForeground(new java.awt.Color(0, 0, 255));
        jLabel12.setText("Start and Goal");
        getContentPane().add(jLabel12);
        jLabel12.setBounds(650, 430, 90, 14);

        jLabel13.setForeground(new java.awt.Color(255, 0, 51));
        jLabel13.setText("Disabled");
        getContentPane().add(jLabel13);
        jLabel13.setBounds(650, 450, 70, 14);

        jLabel14.setForeground(new java.awt.Color(51, 255, 0));
        jLabel14.setText("Current");
        getContentPane().add(jLabel14);
        jLabel14.setBounds(650, 470, 70, 14);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-753)/2, (screenSize.height-765)/2, 753, 765);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Set mouse click to move nodes and not to enable/disable them
     *
     * @param evt
     */
    private void jRadioButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton4ActionPerformed

        try {
            this.map.setAllowDisableNode(false);
            this.map.setAllowMoveNode(true);
            System.out.println("Will allow moving nodes now on mouse click");
        } catch (Exception e) {
            System.out.println("Error allowing moving nodes: " + e);
            showError(e);
        }

    }//GEN-LAST:event_jRadioButton4ActionPerformed

    /**
     * Set mouse click to enable/disable nodes and not to move them
     *
     * @param evt
     */
    private void jRadioButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton3ActionPerformed

        try {
            this.map.setAllowMoveNode(false);
            this.map.setAllowDisableNode(true);
            System.out.println("Will allow enabling/disabling nodes now on mouse click");
        } catch (Exception e) {
            System.out.println("Error allowing enable/disable nodes: " + e);
            showError(e);
        }

    }//GEN-LAST:event_jRadioButton3ActionPerformed

    private void handlewindowGainedFocus(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_handlewindowGainedFocus
    }//GEN-LAST:event_handlewindowGainedFocus

    private void jSlider1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSlider1StateChanged
        JSlider source = (JSlider) evt.getSource();

        //this.printToLog("New slider value is: " + source.getValue());

        try {
            aStarProcess.setTimeDelay(source.getValue());
        } catch (Exception e) {
            System.out.println("Error changing slider value: " + e);
        }
    }//GEN-LAST:event_jSlider1StateChanged

    private void jSlider1CaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jSlider1CaretPositionChanged
    }//GEN-LAST:event_jSlider1CaretPositionChanged

    private void jSlider1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jSlider1PropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jSlider1PropertyChange

    private void jToggleButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButton1ActionPerformed
        if (this.jToggleButton1.isSelected() == true) {
            this.printToLog("The program will now step through the algorithm one event at a time");
            try {
                this.stepByStep = true;
                this.aStarProcess.setStepByStep(true);
            } catch (Exception e) {
                System.out.println("Error setting step-by-step: " + e);
                //showError(e);
            }
        } else {
            this.printToLog("The program will now quickly run the algorithm without stopping");
            try {
                this.stepByStep = false;
                this.aStarProcess.setStepByStep(false);
            } catch (Exception e) {
                System.out.println("Error setting step-by-step: " + e);
                //show_error(e);
            }
        }
    }//GEN-LAST:event_jToggleButton1ActionPerformed
    /**
     * Opens file handler to file text field with path to file for "Connections"
     * file
     *
     * @param evt
     */
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed

        //Create new file chooser
        fc = new JFileChooser();

        try {
            int returnVal = fc.showOpenDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = fc.getSelectedFile();
                //this.printToLog("Selected: " + file.getAbsolutePath());    
                this.jTextField1.setText(file.getAbsolutePath());
            }
        } catch (Exception e) {
            System.out.println("Error in getting connections filename: " + e);
        }
    }//GEN-LAST:event_jButton5ActionPerformed
    /**
     * Opens file handler to file text field with path to file for "Locations"
     * file
     *
     * @param evt
     */
    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed

        //Create new file chooser
        fc = new JFileChooser();

        try {
            int returnVal = fc.showOpenDialog(this);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = fc.getSelectedFile();
                //this.printToLog("Selected: " + file.getAbsolutePath());    
                this.jTextField2.setText(file.getAbsolutePath());
            }
        } catch (Exception e) {
            System.out.println("Error in getting location filename: " + e);
        }

    }//GEN-LAST:event_jButton4ActionPerformed
    /**
     * Reset the algorithm and form
     *
     * @param evt
     */
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        //
        this.reset();
        //Disable reset button
        this.jButton2.setEnabled(false);
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * Set the selected heuristic to 2 = Shortest distance when the user selects
     * this radiobutton
     *
     * @param evt
     */
    private void jRadioButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton2ActionPerformed

        this.selectedHeuristic = 2;

        //this.printToLog("Heuristic " + this.selectedHeuristic + " - 'Shortest Distance' has been selected");
    }//GEN-LAST:event_jRadioButton2ActionPerformed

    private void jTextArea2PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jTextArea2PropertyChange
    }//GEN-LAST:event_jTextArea2PropertyChange
    /**
     * Set the selected heuristic to 1 = Fewest links when the user selects this
     * radiobutton
     *
     * @param evt
     */
    private void jRadioButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton1ActionPerformed

        this.selectedHeuristic = 1;

        //this.printToLog("Heuristic " + this.selectedHeuristic + " - 'Fewest Links' has been selected");
    }//GEN-LAST:event_jRadioButton1ActionPerformed
    /**
     * Load files and create nodes and fills their properties
     *
     * @param evt
     */
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed

        try {
            //Get filenames from text boxes         
            String locFilename = jTextField2.getText();
            String connFilename = jTextField1.getText();

            //Clear local search space
            this.clearSearchSpace();

            //Clear map
            this.map.clear();

            this.printToLog("Loading files.....");

            //Load nodes with their locations from file
            this.loadNodeLocations(locFilename);

            //Load node connections from file
            this.loadNodeConn(connFilename);

            //Clear combo boxes in case some items exist from previous executions of algorithm
            this.jComboBox1.removeAllItems();
            this.jComboBox2.removeAllItems();

            //Load start and goal combo boxes with node names
            this.fillComboBoxes(this.jComboBox1, this.jComboBox2);

            //Try and load previous start and goal nodes from previous algorithm run to combo boxes if they exist
            try {
                this.jComboBox1.setSelectedItem(this.previousStartNode.label);
                this.jComboBox2.setSelectedItem(this.previousGoalNode.label);
                //System.out.println("Successfully loaded previously selected start and goal nodes from last execution of algorithm.");
            } catch (Exception e) {
                System.out.println("Warning - couldn't loading previous start and goal nodes: " + e);
            }
            //Creates the connections between the nodes on the screen
            this.paintNodeConnections();

            //Create the map of the nodes on the screen
            this.paintInitMap();

            //Enabled radio buttons for selection of the heuristic
            this.jRadioButton1.setEnabled(true);
            this.jRadioButton2.setEnabled(true);

            //Enable clicking on map
            this.map.setAllowClicks(true);

            //Enable Step-by-step button
            this.jToggleButton1.setEnabled(true);

            //Enable step slider
            this.jSlider1.setEnabled(true);

            //Ask user to pick start and goal nodes and heuristic
            this.printToLog("*************************************************************************************************************************");
            this.printToLog("Please select a Start and Goal node and a Heuristic and then click 'Start'");
            this.printToLog("Click on nodes to toggle them as 'Enabled' (default) or 'Disabled' so the algorithm does not use them in the search.");
            this.printToLog("Use the toggle 'Step-by-Step' button to specify whether the algorithm should proceed step-by-step (default) or automatically run.");
            this.printToLog("*************************************************************************************************************************");

            //Set button and text field properties
            jTextField1.setEnabled(true);
            jTextField2.setEnabled(true);
            jButton1.setEnabled(true);
            jButton3.setEnabled(true);
            jComboBox1.setEnabled(true);
            jComboBox2.setEnabled(true);

            JOptionPane.showMessageDialog(null, "The files have been loaded successfully.  Please select the appropriate options and start the algorithm.", "Files Loaded", JOptionPane.INFORMATION_MESSAGE);

        } catch (Exception e) {
            //Print out error to output window
            System.out.println(e);
            this.map.clear();
            this.jButton1.setEnabled(false);  //Disable start button
            JOptionPane.showMessageDialog(null, "There was an error loading the files.  Please make sure the files are in the same directory as this application, or that they exist in the specified directories and try again.", "Error", JOptionPane.ERROR_MESSAGE);
        }


    }//GEN-LAST:event_jButton3ActionPerformed
    /**
     * Start A* algorithm
     *
     * @param evt
     */
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        //**********************
        //* Start A* algorithm *
        //**********************

        System.out.println("This command button starts the algorithm");

        //Get start and goal nodes for algorithm
        this.initializeAlgorithm();

        //Check to see if either start or goal node are disabled
        if (this.localStartNode.enabled == false || this.localGoalNode.enabled == false) {
            //Stop starting of algorithm, since start or goal node cannot be disabled
            //this.printToLog("****************************************************************************************************");
            this.printToLog("ERROR: Cannot start algorithm if Start or Goal nodes are disabled, since no solution will be found.");
            this.printToLog("Please enable Start node '" + this.localStartNode.label + "' and Goal node '" + this.localGoalNode.label + "' and restart the algorithm.");

            JOptionPane.showMessageDialog(null, "Start node '" + this.localStartNode.label + "' and Goal node '" + this.localGoalNode.label + "' must be enabled for a solution to be found.  Please enable these nodes and restart the algorithm.", "Error Starting Algorithm", JOptionPane.ERROR_MESSAGE);
        } else {
            //Proceed with algorithm
            try {
                //Disable clicking on map
                this.map.setAllowClicks(false);

                //Disable 'Start' button so two threads can't be running at once
                this.jButton1.setEnabled(false);

                //Disable browse buttons
                this.jButton4.setEnabled(false);
                this.jButton5.setEnabled(false);

                //Change colors for the start and goal nodes
                this.paintStartAndGoal();

                //Instatiate the AstarSearch process
                aStarProcess = new AstarSearch(this.localSearchSpace, this.localStartNode, this.localGoalNode, this.selectedHeuristic, this.jTextArea2, this.map);

                //Set step-by-step value
                aStarProcess.setStepByStep(this.stepByStep);

                try {
                    //Set step_time_delay    
                    int stepTimeDelay = this.jSlider1.getValue();
                    aStarProcess.setTimeDelay(stepTimeDelay);
                } catch (Exception e) {
                    System.out.println("Error setting up algorithm: " + e);
                    showError(e);
                }

                //Start process
                aStarProcess.start();

                //Enable pause button
                //this.jButton6.setEnabled(true);
                //Enable reset button
                this.jButton2.setEnabled(true);

                //Disable combo boxes
                this.jComboBox1.setEnabled(false);
                this.jComboBox2.setEnabled(false);

                //Disable heuristics radio buttons
                this.jRadioButton1.setEnabled(false);
                this.jRadioButton2.setEnabled(false);

                //Disable click radio buttons
                this.jRadioButton3.setEnabled(false);
                this.jRadioButton4.setEnabled(false);
            } catch (Exception E) {
                System.out.println("Error starting A* algorithm " + E);
                showError(E);
            }
            jTextField1.setEnabled(false);
            jTextField2.setEnabled(false);
            //jButton1.setEnabled(false);
            jButton3.setEnabled(false);
        } //end of ELSE to detect if start or goal nodes are disabled
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new mainWindowAstar().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JRadioButton jRadioButton3;
    private javax.swing.JRadioButton jRadioButton4;
    private javax.swing.JRadioButton jRadioButton5;
    private javax.swing.JRadioButton jRadioButton6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSlider jSlider1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JToggleButton jToggleButton1;
    // End of variables declaration//GEN-END:variables

    /**
     * This function loads the initial file that creates the nodes and sets
     * their location
     *
     * @param locFilename name of file that contains the nodes and their
     * locations
     */
    public void loadNodeLocations(String locFilename) {

        System.out.println("Creating nodes and their locations...");

        //Create buffered file reader
        BufferedReader input = null;

        try {
            //Set file input variables
            input = new BufferedReader(new FileReader(locFilename));

            //Initialize string to read in lines from file
            String line = null;

            //Loop to read file line-by-line
            while ((line = input.readLine()) != null) {
                //Process each line of text file

                //System.out.println(line); //Test read file by printing the entire line

                //PARSING CODE for Location of nodes text file "locsamp.txt"
                String nodeInfo[] = line.split(" ");
                if ((nodeInfo != null) && (nodeInfo.length > 1)) {
                    //Create new node with parsed information (label, x, y)    
                    HeuristicsNode newNode = new HeuristicsNode(nodeInfo[0], Integer.parseInt(nodeInfo[1]), Integer.parseInt(nodeInfo[2]));

                    //Add new node to search space list
                    this.localSearchSpace.add(newNode);

                    //Print node info to output screen
                    System.out.println("Created new node '" + newNode.label + "', x = " + newNode.location.x + ", y = " + newNode.location.y + " and added it to the search space");
                }
            }

        } catch (Exception e) {
            System.out.println(e);
            showError(e);
        }

        try {
            //Close input file
            input.close();

        } catch (java.io.IOException e) {
            System.out.println(e);
        }

    }

    /**
     * This function loads the connections file that sets up how each node is
     * connected to its neighbors
     *
     * @param connFilename name of the file that contains the connections
     * between each node in the network
     */
    public void loadNodeConn(String connFilename) {

        System.out.println("Creating node connections...");

        //Create buffered file reader
        BufferedReader input = null;

        try {
            //Set file input variables
            input = new BufferedReader(new FileReader(connFilename));

            //Initialize string to read in lines from file
            String line = null;

            //Loop to read file line-by-line
            while ((line = input.readLine()) != null) {
                //Process each line of text file

                //System.out.println("File line: " + line); //Test read file by printing the entire line

                //PARSING CODE for Location of nodes text file "locsamp.txt"
                String nodeInfo[] = line.split(" ");
                if ((nodeInfo != null) && (nodeInfo.length > 1)) {

                    //System.out.println("Searching for Node '" + node_info[0] + "' to form connections from....");

                    //Get nodeA to add connections to 
                    NodeXY nodeA = (NodeXY) this.localSearchSpace.findNode(nodeInfo[0]);

                    //System.out.println("Got node '" + nodeInfo[0] + "'.");

                    //Get # of nodes that node_A is connected to
                    int numConn = Integer.parseInt(nodeInfo[1]);

                    //Print node info                    
                    //System.out.println("Node '" + nodeInfo[0] + "' has " + numConn + " initial connections:");
                    //Get each connection
                    for (int i = 2; i < (numConn + 2); i++) {

                        //System.out.println("Searching for Node '" + nodeInfo[i] + "' to form connection to....");

                        //Get each node to connect to
                        NodeXY nodeB = (NodeXY) this.localSearchSpace.findNode(nodeInfo[i]);

                        //System.out.println("Got node '" + nodeInfo[i] + "'.");

                        if (nodeB != null && nodeA != null) {
                            //Add one-way connection from nodeA to nodeB
                            nodeA.addConnToChild(nodeB);

                            //Add link to search space
                            LinkXY link = new LinkXY(nodeA, nodeB);
                            this.localSearchSpace.add(link);

                        } else {
                            System.out.println("Error:  Tried to form connection to or from a node that does not exist in search space.");
                        }
                        //Prints the label for each node that will be connected to
                        //System.out.println(nodeInfo[i]);
                    }

                }

            }
            this.printToLog("Files were successfully loaded.");

            //JOptionPane.showMessageDialog(this, "Files successfully loaded.  Please choose the start and goal nodes and click 'Start'","Files loaded", JOptionPane.INFORMATION_MESSAGE);

        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, e, "Error", JOptionPane.ERROR_MESSAGE);
            System.out.println(e);
        }

        System.out.println("Finished creating node connections.");

        try {
            //Close input file
            input.close();

        } catch (java.io.IOException e) {
            System.out.println(e);
            showError(e);
        }
    }

    /**
     * This function fills the start and goal combo boxes with the nodes in the
     * search space
     *
     *
     * @param jComboBox1 box to be filled with nodes in search space to allow
     * use to pick the starting node
     * @param jComboBox2 box to be filled with nodes in search space to allow
     * use to pick the goal node
     */
    public void fillComboBoxes(javax.swing.JComboBox jComboBox1, javax.swing.JComboBox jComboBox2) {

        //Temp node to loop through search space
        NodeXY tempNode;

        //Get iterator to loop through searchSpace
        Iterator i = this.localSearchSpace.getNodeIterator();

        while (i.hasNext()) {
            //Get next node
            tempNode = (NodeXY) i.next();
            //Add string to combo boxes
            jComboBox1.addItem(tempNode.label);
            jComboBox2.addItem(tempNode.label);
        }
    }

    /**
     * This function initializes the start and goal nodes of the algorithm
     */
    public void initializeAlgorithm() {

        NodeXY tempNode;  //Temp node to loop through search space

        Iterator i = this.localSearchSpace.getNodeIterator();  //Get iterator to loop through search_space

        while (i.hasNext()) {
            //Get next node
            tempNode = (NodeXY) i.next();
            //Clear node attributes used for search (allows multiple searches)
            tempNode.costFromStart = 0;
            //temp_node.enabled = true;  //Commented out to allow nodes to be disabled
            tempNode.estCostToGoal = 0;
            tempNode.pathParent = null;
        }

        //Get names of selected start and goal nodes
        String startNodeLabel = (String) jComboBox1.getSelectedItem();
        String goalNodeLabel = (String) jComboBox2.getSelectedItem();

        //Find start and goal nodes                
        localStartNode = (HeuristicsNode) this.localSearchSpace.findNode(startNodeLabel);
        localGoalNode = (HeuristicsNode) this.localSearchSpace.findNode(goalNodeLabel);

    }

    /**
     * This method prints output shown to the user in the textbox on the screen
     *
     * @param text text to be shown to user in textbox
     */
    public void printToLog(String text) {

        try {
            this.jTextArea2.append(text + newline); //Adds newline character so each entry appears on a new line

            //Moves cursor to the end of the text area to keep new text in view
            this.jTextArea2.setCaretPosition(jTextArea2.getDocument().getLength());

            //Print out to output screen also
            System.out.println(text);
        } catch (Exception e) {
            System.out.println("Error in mainWindow.print_to_log:" + e);
            showError(e);
        }

    }

    /**
     * Creates the map on the UI
     */
    public void createMap() {

        try {
            //Create map
            map = new MapDisplay();

            //Set map variables for search space
            this.map.setSearchSpace(this.localSearchSpace, this.SEARCH_SPACE_WIDTH, this.SEARCH_SPACE_HEIGHT, this.SCALE, this.NORMAL_NODE_SIZE, this.EXPANDED_NODE_SIZE);

            //Set map variable to print messages to the user
            map.setTextLog(this.jTextArea2);

            //Setup map
            //map.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());  //Changed to below "null" due to error running .jar
            map.setLayout(null);
            map.setBackground(new java.awt.Color(251, 250, 247));
            map.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0)));
            this.getContentPane().add(map);
            map.setBounds(20, 170, (int) ((SEARCH_SPACE_WIDTH + 30) * SCALE), (int) ((SEARCH_SPACE_HEIGHT + 30) * SCALE)); //"+ 20" value lets you read the labels on the nodes on the far bottom and right extremes

            //Show the blank map
            map.show();
        } catch (Exception e) {
            System.out.println("Error creating map: " + e);
            showError(e);
        }
    }

    /**
     * Draws the initial view of nodes on the map
     */
    public void paintInitMap() {
        //Draw initial node setup on the map
        Iterator i = this.localSearchSpace.getNodeIterator();

        HeuristicsNode tempNode; //Variable to loop through search space

        while (i.hasNext()) {
            tempNode = (HeuristicsNode) i.next();  //Get next node

            tempNode.drawNode(map, tempNode.color, NORMAL_NODE_SIZE);  //Draw node on map            
        }
    }

    /**
     * Paints the colors of the start and goal nodes on the map
     */
    public void paintStartAndGoal() {

        Color color = Color.BLACK;  //Color for node (default = BLACK)

        //Change color for start_node
        color = Color.BLUE;
        this.localStartNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map    
        this.localStartNode.previousColor = Color.BLUE;

        //Change color for goal_node 
        color = Color.BLUE;
        this.localGoalNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map                        
        this.localGoalNode.previousColor = Color.BLUE;
    }

    /**
     * Paints the colors of the start and goal nodes on the map *
     */
    public void resetStartGoalCurrentColors() {
        Color color = Color.DARK_GRAY;  //Color for node

        //Change color for start_node
        this.localStartNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map    
        this.localStartNode.previousColor = color;

        //Change color for goal_node 
        this.localGoalNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map                        
        this.localGoalNode.previousColor = color;

        //Change color for currentNode
        try {
            HeuristicsNode tempNode = this.aStarProcess.getCurrentNode();
            tempNode.drawNode(map, color, NORMAL_NODE_SIZE);  //Draw node on map                        
        } catch (Exception e) {
            System.out.println("Error resetting current node color: " + e);
        }

    }

    /**
     * Paints the connections between the nodes
     */
    public void paintNodeConnections() {

        Color color = Color.LIGHT_GRAY;  //Color for link

        //*** Draw all links on map ***
        Iterator i2 = this.localSearchSpace.getLinkIterator();

        LinkXY tempLink; //Variable to loop through search space

        while (i2.hasNext()) {
            tempLink = (LinkXY) i2.next();  //Get next link

            tempLink.drawLink(this.map, color);  //Draw link on map                            
        }
    }

    /**
     * Resets the algorithm and GUI so that the user can restart the algorithm
     */
    public void reset() {

        //Save last start and goal so they can be reloaded
        this.previousStartNode = this.localStartNode;
        this.previousGoalNode = this.localGoalNode;

        //Clear map
        map.clear();

        //Clear combo boxes
        //this.jComboBox1.removeAllItems();
        //this.jComboBox2.removeAllItems();

        try {
            this.aStarProcess.suspend();
        } catch (Exception e) {
            System.out.println(e);
        }

        //Reset link traveled status and colors
        resetLinkStatus();

        //Reset start and goal and current node colors
        resetStartGoalCurrentColors();

        //Repaint links on map
        paintNodeConnections();

        //Repaint nodes on map
        paintInitMap();

        //Enable Start button and combo boxes
        this.jToggleButton1.setEnabled(true);
        this.jComboBox1.setEnabled(true);
        this.jComboBox2.setEnabled(true);
        this.jRadioButton1.setEnabled(true);
        this.jRadioButton2.setEnabled(true);
        this.jRadioButton3.setEnabled(true);
        this.jRadioButton4.setEnabled(true);
        this.jButton1.setEnabled(true);
        this.jSlider1.setEnabled(true);

        //Enable load buttons and fields
        this.jButton3.setEnabled(true);
        this.jButton4.setEnabled(true);
        this.jButton5.setEnabled(true);
        this.jTextField1.setEnabled(true);
        this.jTextField2.setEnabled(true);

        //Enable clicking on map
        this.map.setAllowClicks(true);

        //Print reset message to the user
        this.printToLog("The algorithm has been reset.");
    }

    /**
     * Resets all links to their default states
     */
    public void resetLinkStatus() {

        //*** Draw all links on map ***
        Iterator i2 = this.localSearchSpace.getLinkIterator();

        LinkXY tempLink; //Variable to loop through search space

        while (i2.hasNext()) {
            tempLink = (LinkXY) i2.next();  //Get next link

            tempLink.resetToDefault();  //Reset link                     
        }
    }

    /**
     * Clears the search space of all nodes
     */
    public void clearSearchSpace() {

        //Point to new search space
        this.localSearchSpace = new SearchSpace();

        //Set map variables for new search space
        this.map.setSearchSpace(this.localSearchSpace, this.SEARCH_SPACE_WIDTH, this.SEARCH_SPACE_HEIGHT, this.SCALE, this.NORMAL_NODE_SIZE, this.EXPANDED_NODE_SIZE);
    }

    /**
     * Shows the error to the user
     *
     * @param e Exception to show to the user
     */
    public void showError(Exception e) {
        JOptionPane.showMessageDialog(null, "Error: " + e, "Error", JOptionPane.ERROR_MESSAGE);
    }
}